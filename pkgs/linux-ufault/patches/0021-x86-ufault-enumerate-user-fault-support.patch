From ed10d459e506bb89340dd36813593d81d63e087f Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 14 Nov 2025 11:36:18 +0100
Subject: [PATCH 21/29] x86/ufault: enumerate user fault support

---
 arch/x86/Kconfig                         |  5 +++++
 arch/x86/include/asm/disabled-features.h |  8 +++++++-
 arch/x86/kernel/cpu/common.c             | 15 +++++++++++++++
 3 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 7cb9155ae9b5..6ee0679789ae 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1901,6 +1901,11 @@ config X86_UINTR_BLOCKING
 	  experimental and flaky. Enable this only if you are specifically
 	  testing this. Failures can happen when stressed.
 
+config X86_USER_FAULTS
+	bool "User Faults (UFAULT)"
+	depends on X86_64
+	depends on CPU_SUP_INTEL
+
 choice
 	prompt "TSX enable mode"
 	depends on CPU_SUP_INTEL
diff --git a/arch/x86/include/asm/disabled-features.h b/arch/x86/include/asm/disabled-features.h
index f427135c0bfb..fd99f4c0ca20 100644
--- a/arch/x86/include/asm/disabled-features.h
+++ b/arch/x86/include/asm/disabled-features.h
@@ -93,6 +93,12 @@
 # define DISABLE_UINTR		(1 << (X86_FEATURE_UINTR & 31))
 #endif
 
+#ifdef CONFIG_X86_USER_FAULTS
+# define DISABLE_UFAULT		0
+#else
+# define DISABLE_UFAULT		(1 << (X86_FEATURE_UFAULT & 31))
+#endif
+
 /*
  * Make sure to add features to the correct mask
  */
@@ -115,7 +121,7 @@
 #define DISABLED_MASK16	(DISABLE_PKU|DISABLE_OSPKE|DISABLE_LA57|DISABLE_UMIP| \
 			 DISABLE_ENQCMD)
 #define DISABLED_MASK17	0
-#define DISABLED_MASK18	(DISABLE_UINTR)
+#define DISABLED_MASK18	(DISABLE_UINTR|DISABLE_UFAULT)
 #define DISABLED_MASK19	0
 #define DISABLED_MASK_CHECK BUILD_BUG_ON_ZERO(NCAPINTS != 20)
 
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 7d61b9260a7b..84714f475397 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -434,6 +434,18 @@ static void setup_uintr(struct cpuinfo_x86 *c)
 	cr4_clear_bits(X86_CR4_UINTR);
 }
 
+static void setup_ufault(struct cpuinfo_x86 *c)
+{
+	if (!cpu_feature_enabled(X86_FEATURE_UFAULT) ||
+	    !cpu_has(c, X86_FEATURE_UFAULT)) {
+		/* In case it was enabled in a previous boot.  */
+		cr4_clear_bits(X86_CR4_UFAULT);
+		return;
+	}
+
+	pr_info_once("x86: User Faults (UFAULT) enabled\n");
+}
+
 static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 {
 	unsigned long eflags = native_save_fl();
@@ -1889,6 +1901,9 @@ static void identify_cpu(struct cpuinfo_x86 *c)
 	/* Set up User Interrupts */
 	setup_uintr(c);
 
+	/* Set up User Faults */
+	setup_ufault(c);
+
 	/* Enable FSGSBASE instructions if available. */
 	if (cpu_has(c, X86_FEATURE_FSGSBASE)) {
 		cr4_set_bits(X86_CR4_FSGSBASE);
-- 
2.52.0

