From e59f9c06d425262589e65b203ed3b922295b21d8 Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 25 Jul 2025 13:33:10 +0200
Subject: [PATCH 27/28] prctl: add prctl(PR_UFAULT) to enable/disable user
 faults

---
 arch/x86/include/asm/ufault.h |  8 ++++++
 arch/x86/kernel/ufault.c      | 50 +++++++++++++++++++++++++++++++++++
 include/uapi/linux/prctl.h    |  5 ++++
 kernel/sys.c                  |  6 +++++
 4 files changed, 69 insertions(+)

diff --git a/arch/x86/include/asm/ufault.h b/arch/x86/include/asm/ufault.h
index f66e0d0d5e98..cc07d6787a73 100644
--- a/arch/x86/include/asm/ufault.h
+++ b/arch/x86/include/asm/ufault.h
@@ -2,6 +2,7 @@
 #ifndef _ASM_X86_UFAULT_H
 #define _ASM_X86_UFAULT_H
 
+#include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/types.h>
 
@@ -29,11 +30,18 @@ static __always_inline void stuf(void)
 void switch_ufault(struct task_struct *prev, struct task_struct *next);
 void clear_ufault(struct task_struct *task);
 
+int prctl_ufault(unsigned long opt, unsigned long arg);
+
 #else /* !CONFIG_X86_USER_FAULTS */
 
 static inline void switch_ufault(struct task_struct *prev, struct task_struct *next) {}
 static inline void clear_ufault(struct task_struct *task) {}
 
+static inline int prctl_ufault(unsigned long opt, unsigned long arg)
+{
+	return -EINVAL;
+}
+
 #endif /* CONFIG_X86_USER_FAULTS */
 
 #endif /* _ASM_X86_UFAULT_H */
diff --git a/arch/x86/kernel/ufault.c b/arch/x86/kernel/ufault.c
index 1053b15d54e5..ecb67ec61b49 100644
--- a/arch/x86/kernel/ufault.c
+++ b/arch/x86/kernel/ufault.c
@@ -1,8 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
 
+#include <linux/preempt.h>
+#include <linux/prctl.h>
 #include <linux/sched.h>
 
 #include <asm/cpufeature.h>
+#include <asm/processor-flags.h>
 #include <asm/tlbflush.h>
 #include <asm/ufault.h>
 
@@ -39,3 +42,50 @@ void clear_ufault(struct task_struct *task)
 	task->thread.ufault_handler = 0;
 	task->thread.uff = 0;
 }
+
+static void disable_ufault(void)
+{
+	preempt_disable();
+	if (test_and_clear_thread_flag(TIF_UFAULT))
+		cr4_clear_bits(X86_CR4_UFAULT);
+	preempt_enable();
+}
+
+static void enable_ufault(void)
+{
+	preempt_disable();
+	if (!test_and_set_thread_flag(TIF_UFAULT))
+		cr4_set_bits(X86_CR4_UFAULT);
+	preempt_enable();
+}
+
+static void set_ufault_handler(unsigned long handler)
+{
+	wrmsrl(MSR_IA32_UFAULT_HANDLER, handler);
+
+	current->thread.ufault_handler = handler;
+}
+
+int prctl_ufault(unsigned long opt, unsigned long arg)
+{
+	if (!cpu_feature_enabled(X86_FEATURE_UFAULT))
+		return -EINVAL;
+
+	switch (opt) {
+	case PR_UFAULT_DISABLE:
+		if (arg)
+			return -EINVAL;
+		disable_ufault();
+		return 0;
+	case PR_UFAULT_ENABLE:
+		set_ufault_handler(arg);
+		enable_ufault();
+		return 0;
+	case PR_UFAULT_STATUS:
+		if (arg)
+			return -EINVAL;
+		return test_tsk_thread_flag(current, TIF_UFAULT);
+	default:
+		return -EINVAL;
+	}
+}
diff --git a/include/uapi/linux/prctl.h b/include/uapi/linux/prctl.h
index 51c4e8c82b1e..c36b8d41fa64 100644
--- a/include/uapi/linux/prctl.h
+++ b/include/uapi/linux/prctl.h
@@ -386,4 +386,9 @@ struct prctl_mm_map {
 # define PR_FUTEX_HASH_SET_SLOTS	1
 # define PR_FUTEX_HASH_GET_SLOTS	2
 
+#define PR_UFAULT			79
+# define PR_UFAULT_DISABLE		0
+# define PR_UFAULT_ENABLE		1
+# define PR_UFAULT_STATUS		2
+
 #endif /* _LINUX_PRCTL_H */
diff --git a/kernel/sys.c b/kernel/sys.c
index 8b58eece4e58..926643094546 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -74,6 +74,7 @@
 
 #include <linux/uaccess.h>
 #include <asm/io.h>
+#include <asm/ufault.h>
 #include <asm/unistd.h>
 
 #include <trace/events/task.h>
@@ -2868,6 +2869,11 @@ SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 	case PR_FUTEX_HASH:
 		error = futex_hash_prctl(arg2, arg3, arg4);
 		break;
+	case PR_UFAULT:
+		if (arg4 || arg5)
+			return -EINVAL;
+		error = prctl_ufault(arg2, arg3);
+		break;
 	default:
 		trace_task_prctl_unknown(option, arg2, arg3, arg4, arg5);
 		error = -EINVAL;
-- 
2.52.0

