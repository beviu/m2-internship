From 6cc368334034452758913168f3e847f1d0c1e0da Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 25 Jul 2025 13:33:10 +0200
Subject: [PATCH 24/28] x86/process: add TIF_UFAULT to track task user fault
 status

---
 arch/x86/include/asm/thread_info.h |  2 ++
 arch/x86/include/asm/ufault.h      | 13 +++++++++++++
 arch/x86/kernel/Makefile           |  1 +
 arch/x86/kernel/process.c          |  3 +++
 arch/x86/kernel/process_64.c       |  3 +++
 arch/x86/kernel/ufault.c           | 24 ++++++++++++++++++++++++
 6 files changed, 46 insertions(+)
 create mode 100644 arch/x86/kernel/ufault.c

diff --git a/arch/x86/include/asm/thread_info.h b/arch/x86/include/asm/thread_info.h
index e71e0e8362ed..512c57503b1a 100644
--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -102,6 +102,7 @@ struct thread_info {
 #define TIF_BLOCKSTEP		26	/* set when we want DEBUGCTLMSR_BTF */
 #define TIF_LAZY_MMU_UPDATES	27	/* task is updating the mmu lazily */
 #define TIF_ADDR32		28	/* 32-bit address space on 64 bits */
+#define TIF_UFAULT		29	/* User Faults enabled */
 
 #define _TIF_SSBD		BIT(TIF_SSBD)
 #define _TIF_SPEC_IB		BIT(TIF_SPEC_IB)
@@ -116,6 +117,7 @@ struct thread_info {
 #define _TIF_SINGLESTEP		BIT(TIF_SINGLESTEP)
 #define _TIF_LAZY_MMU_UPDATES	BIT(TIF_LAZY_MMU_UPDATES)
 #define _TIF_ADDR32		BIT(TIF_ADDR32)
+#define _TIF_UFAULT		(1 << TIF_UFAULT)
 
 /* flags to check in __switch_to() */
 #define _TIF_WORK_CTXSW_BASE					\
diff --git a/arch/x86/include/asm/ufault.h b/arch/x86/include/asm/ufault.h
index 0f43b28fb71d..f66e0d0d5e98 100644
--- a/arch/x86/include/asm/ufault.h
+++ b/arch/x86/include/asm/ufault.h
@@ -2,6 +2,7 @@
 #ifndef _ASM_X86_UFAULT_H
 #define _ASM_X86_UFAULT_H
 
+#include <linux/sched.h>
 #include <linux/types.h>
 
 static __always_inline bool testuf(void)
@@ -23,4 +24,16 @@ static __always_inline void stuf(void)
 	asm volatile(".long 0xeb010ff3" ::: "memory");
 }
 
+#ifdef CONFIG_X86_USER_FAULTS
+
+void switch_ufault(struct task_struct *prev, struct task_struct *next);
+void clear_ufault(struct task_struct *task);
+
+#else /* !CONFIG_X86_USER_FAULTS */
+
+static inline void switch_ufault(struct task_struct *prev, struct task_struct *next) {}
+static inline void clear_ufault(struct task_struct *task) {}
+
+#endif /* CONFIG_X86_USER_FAULTS */
+
 #endif /* _ASM_X86_UFAULT_H */
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 4cacf7c8fadc..ba99b08b40ea 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -143,6 +143,7 @@ obj-$(CONFIG_UPROBES)			+= uprobes.o
 obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o
 obj-$(CONFIG_SCHED_MC_PRIO)		+= itmt.o
 obj-$(CONFIG_X86_USER_INTERRUPTS)	+= uintr.o
+obj-$(CONFIG_X86_USER_FAULTS)	+= ufault.o
 obj-$(CONFIG_X86_UMIP)			+= umip.o
 
 obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index 788f2912adb9..f6ce1b5fa852 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -30,6 +30,7 @@
 #include <linux/hw_breakpoint.h>
 #include <linux/entry-common.h>
 #include <asm/uintr.h>
+#include <asm/ufault.h>
 #include <asm/cpu.h>
 #include <asm/cpuid/api.h>
 #include <asm/apic.h>
@@ -125,6 +126,8 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 	dst->thread.uitt_activated = false;
 #endif
 
+	clear_ufault(dst);
+
 	return 0;
 }
 
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index b5347ed7d949..c119c6706b80 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -55,6 +55,7 @@
 #include <asm/xen/hypervisor.h>
 #include <asm/vdso.h>
 #include <asm/resctrl.h>
+#include <asm/ufault.h>
 #include <asm/uintr.h>
 #include <asm/unistd.h>
 #include <asm/fsgsbase.h>
@@ -679,6 +680,8 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 	if (cpu_feature_enabled(X86_FEATURE_UINTR))
 		switch_uintr_finish(next_p);
 
+	switch_ufault(prev_p, next_p);
+
 	switch_to_extra(prev_p, next_p);
 
 	if (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) {
diff --git a/arch/x86/kernel/ufault.c b/arch/x86/kernel/ufault.c
new file mode 100644
index 000000000000..8133e90495a7
--- /dev/null
+++ b/arch/x86/kernel/ufault.c
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/sched.h>
+
+#include <asm/cpufeature.h>
+#include <asm/tlbflush.h>
+#include <asm/ufault.h>
+
+void switch_ufault(struct task_struct *prev, struct task_struct *next)
+{
+	bool prev_ufault = test_tsk_thread_flag(prev, TIF_UFAULT);
+	bool next_ufault = test_tsk_thread_flag(next, TIF_UFAULT);
+
+	if (!cpu_feature_enabled(X86_FEATURE_UFAULT))
+		return;
+
+	if (next_ufault != prev_ufault)
+		cr4_toggle_bits_irqsoff(X86_CR4_UFAULT);
+}
+
+void clear_ufault(struct task_struct *task)
+{
+	clear_tsk_thread_flag(task, TIF_UFAULT);
+}
-- 
2.52.0

