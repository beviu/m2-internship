From 91c753f4eb8c9d11b0b1c76851e89b9d31335c72 Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 25 Jul 2025 13:33:10 +0200
Subject: [PATCH 25/28] x86/process: save and restore UFF during context switch

---
 arch/x86/include/asm/processor.h |  6 ++++++
 arch/x86/kernel/ufault.c         | 12 ++++++++++++
 2 files changed, 18 insertions(+)

diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 21d7f1bdf70c..36627c96c70b 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -500,6 +500,12 @@ struct thread_struct {
 
 	unsigned int		iopl_warn:1;
 
+#ifdef CONFIG_X86_USER_FAULTS
+	/* The User Fault Flag is a user-space flag that needs to be set in addition
+	   to the CR4.UFAULT bit to enable User Faults. */
+	unsigned int		uff:1;
+#endif
+
 #ifdef CONFIG_X86_USER_INTERRUPTS
 	/* User Interrupt state*/
 
diff --git a/arch/x86/kernel/ufault.c b/arch/x86/kernel/ufault.c
index 8133e90495a7..db6854c9fea5 100644
--- a/arch/x86/kernel/ufault.c
+++ b/arch/x86/kernel/ufault.c
@@ -16,9 +16,21 @@ void switch_ufault(struct task_struct *prev, struct task_struct *next)
 
 	if (next_ufault != prev_ufault)
 		cr4_toggle_bits_irqsoff(X86_CR4_UFAULT);
+
+	if (prev_ufault)
+		prev->thread.uff = testuf();
+
+	if (next_ufault && next->thread.uff != prev->thread.uff) {
+		if (next->thread.uff)
+			stuf();
+		else
+			cluf();
+	}
 }
 
 void clear_ufault(struct task_struct *task)
 {
 	clear_tsk_thread_flag(task, TIF_UFAULT);
+
+	task->thread.uff = 0;
 }
-- 
2.52.0

