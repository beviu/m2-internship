From 58457b040fe91bc9bdefcf93a0b1033d1d6fa1ad Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Mon, 5 Jan 2026 14:37:33 +0100
Subject: [PATCH 19/20] arch-x86: Implement user fault delivery

Code was written by Berk and modified a bit to not reuse the existing
user interrupt ABI because compilers would end handlers with the UIRET
instruction but we don't want to use it as we have our own UFF flag that
UIRET does not know about.
---
 src/arch/x86/faults.cc            | 25 ++++++++++++++++++
 src/arch/x86/faults.hh            | 32 ++++++++++++++++++++++
 src/arch/x86/isa/insts/romutil.py | 44 +++++++++++++++++++++++++++++++
 src/arch/x86/pagetable_walker.cc  | 33 ++++++++++++++++-------
 src/arch/x86/pagetable_walker.hh  |  1 +
 src/arch/x86/regs/misc.hh         |  1 +
 src/arch/x86/tlb.cc               | 15 ++++++++---
 7 files changed, 137 insertions(+), 14 deletions(-)

diff --git a/src/arch/x86/faults.cc b/src/arch/x86/faults.cc
index fce92b1fb4..8809db03c8 100644
--- a/src/arch/x86/faults.cc
+++ b/src/arch/x86/faults.cc
@@ -179,6 +179,31 @@ PageFault::describe() const
     return ss.str();
 }
 
+void
+UserFault::invoke(ThreadContext *tc, const StaticInstPtr &inst)
+{
+    if (!FullSystem)
+        panic("User Faults are only supported in full-system mode.");
+
+    HandyM5Reg m5reg = tc->readMiscRegNoEffect(misc_reg::M5Reg);
+    if (m5reg.mode != LongMode)
+        panic("User Faults are only supported in long mode.");
+
+    PCState pc = tc->pcState().as<PCState>();
+
+    DPRINTF(Faults, "RIP %#x: User Fault at %s with code %#x\n", pc.pc(), addr, code);
+
+    tc->setReg(intRegMicro(1), pc.pc());
+    tc->setReg(intRegMicro(2), addr);
+    tc->setReg(intRegMicro(3), code);
+
+    MicroPC entry = romMicroPC(X86ISAInst::rom_labels::extern_label_userFault);
+    pc.upc(entry);
+    pc.nupc(entry + 1);
+
+    tc->pcState(pc);
+}
+
 void
 InitInterrupt::invoke(ThreadContext *tc, const StaticInstPtr &inst)
 {
diff --git a/src/arch/x86/faults.hh b/src/arch/x86/faults.hh
index a1ff1b02c2..ea84ee5f89 100644
--- a/src/arch/x86/faults.hh
+++ b/src/arch/x86/faults.hh
@@ -298,6 +298,38 @@ class PageFault : public X86Fault
     virtual std::string describe() const;
 };
 
+class UserFault : public FaultBase
+{
+  protected:
+    BitUnion8(UserFaultCode)
+        Bitfield<0> present;
+        Bitfield<1> write;
+        Bitfield<2> fetch;
+    EndBitUnion(UserFaultCode)
+
+    Addr addr;
+    UserFaultCode code;
+
+  public:
+    UserFault(Addr _addr, bool present, BaseMMU::Mode mode) :
+        addr(_addr), code(0)
+    {
+        code.present = present;
+        code.write = (mode == BaseMMU::Write);
+        code.fetch = (mode == BaseMMU::Execute);
+    }
+
+    FaultName
+    name() const override
+    {
+        return "User Fault";
+    }
+
+    void
+    invoke(ThreadContext *tc, const StaticInstPtr &inst=
+                nullStaticInstPtr) override;
+};
+
 class X87FpExceptionPending : public X86Fault
 {
   public:
diff --git a/src/arch/x86/isa/insts/romutil.py b/src/arch/x86/isa/insts/romutil.py
index 7082b4d4a5..10c9b3596a 100644
--- a/src/arch/x86/isa/insts/romutil.py
+++ b/src/arch/x86/isa/insts/romutil.py
@@ -269,5 +269,49 @@ def rom
 
     eret
 };
+
+def rom
+{
+    extern userFault:
+
+    # t1 - The faulting RIP.
+    # t2 - The address trying to be accessed.
+    # t3 - The user fault code.
+
+    # holdRSP := RSP;
+    mov t4, t0, rsp, dataSize=8
+
+    # RSP := RSP & ~FH; // force the stack to be 16-byte aligned
+    limm t5, "~(uint64_t)0xF", dataSize=8
+    and rsp, rsp, t5, dataSize=8
+
+    # UFF := 0;
+    wrval ctrlRegIdx("misc_reg::Uff"), t0, dataSize=8
+
+    # Push holdRSP;
+    # Push RFLAGS;
+    # Push RIP;
+    # Push ADDR;
+    # Push CODE;
+    rflags t6, dataSize=8
+    st t4, ss, [1, t0, rsp], -8, dataSize=8, addressSize=8
+    st t6, ss, [1, t0, rsp], -16, dataSize=8, addressSize=8
+    st t1, ss, [1, t0, rsp], -24, dataSize=8, addressSize=8
+    st t2, ss, [1, t0, rsp], -32, dataSize=8, addressSize=8
+    st t3, ss, [1, t0, rsp], -40, dataSize=8, addressSize=8
+    subi rsp, rsp, 40, dataSize=8
+
+    # RFLAGS.TF := 0;
+    # RFLAGS.RF := 0;
+    limm t7, "~(uint64_t)(TFBit | RFBit)", dataSize=8
+    and t8, t6, t7, dataSize=8
+    wrflags t8, t0, dataSize=8
+
+    # RIP := UFHANDLER;
+    rdval t9, ctrlRegIdx("misc_reg::Ufhandler"), dataSize=8
+    wrip t9, t0, dataSize=8
+
+    eret
+};
 """
 )
diff --git a/src/arch/x86/pagetable_walker.cc b/src/arch/x86/pagetable_walker.cc
index bac174afb0..8172d225cf 100644
--- a/src/arch/x86/pagetable_walker.cc
+++ b/src/arch/x86/pagetable_walker.cc
@@ -304,6 +304,10 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
     bool doTLBInsert = false;
     bool doEndWalk = false;
     bool badNX = pte.nx && mode == BaseMMU::Execute && enableNX;
+    HandyM5Reg m5Reg = tc->readMiscRegNoEffect(misc_reg::M5Reg);
+    bool inUser = m5Reg.cpl == 3;
+    CR4 cr4 = tc->readMiscRegNoEffect(misc_reg::Cr4);
+    bool doUserFault = inUser && cr4.ufault && tc->readMiscRegNoEffect(X86ISA::misc_reg::Uff);
     switch(state) {
       case LongPML4:
         DPRINTF(PageTableWalker, "Got long mode PML4 entry %#016x.\n", pte);
@@ -314,7 +318,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         entry.noExec = pte.nx;
@@ -329,7 +333,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = entry.user && pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         nextState = LongPD;
@@ -342,7 +346,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = entry.user && pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         if (!pte.ps) {
@@ -371,7 +375,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = entry.user && pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         entry.paddr = mbits(pte, 51, 12);
@@ -388,7 +392,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         nextRead = mbits(pte, 51, 12) + vaddr.pael2 * dataSize;
         if (!pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         nextState = PAEPD;
@@ -401,7 +405,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         if (!pte.ps) {
@@ -431,7 +435,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = entry.user && pte.u;
         if (badNX || !pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         entry.paddr = mbits(pte, 51, 12);
@@ -450,7 +454,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = pte.u;
         if (!pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         if (!pte.ps) {
@@ -479,7 +483,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = pte.u;
         if (!pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         // 4 KB page
@@ -495,7 +499,7 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
         entry.user = pte.u;
         if (!pte.p) {
             doEndWalk = true;
-            fault = pageFault(pte.p);
+            fault = doUserFault ? userFault(pte.p) : pageFault(pte.p);
             break;
         }
         entry.paddr = mbits(pte, 31, 12);
@@ -756,5 +760,14 @@ Walker::WalkerState::pageFault(bool present)
                                        m5reg.cpl == 3, false);
 }
 
+Fault
+Walker::WalkerState::userFault(bool present)
+{
+    DPRINTF(PageTableWalker, "Raising user fault.\n");
+    if (mode == BaseMMU::Execute && !enableNX)
+        mode = BaseMMU::Read;
+    return std::make_shared<UserFault>(entry.vaddr, present, mode);
+}
+
 } // namespace X86ISA
 } // namespace gem5
diff --git a/src/arch/x86/pagetable_walker.hh b/src/arch/x86/pagetable_walker.hh
index 14e7c9976f..79514cc6e5 100644
--- a/src/arch/x86/pagetable_walker.hh
+++ b/src/arch/x86/pagetable_walker.hh
@@ -144,6 +144,7 @@ namespace X86ISA
             void sendPackets();
             void endWalk();
             Fault pageFault(bool present);
+            Fault userFault(bool present);
         };
 
         friend class WalkerState;
diff --git a/src/arch/x86/regs/misc.hh b/src/arch/x86/regs/misc.hh
index 0d49bfe9da..5456f4bbab 100644
--- a/src/arch/x86/regs/misc.hh
+++ b/src/arch/x86/regs/misc.hh
@@ -646,6 +646,7 @@ BitUnion64(CR3)
 EndBitUnion(CR3)
 
 BitUnion64(CR4)
+    Bitfield<26> ufault; // Enable User Faults
     Bitfield<18> osxsave; // Enable XSAVE and Proc Extended States
     Bitfield<17> pcide; // PCID Enable
     Bitfield<16> fsgsbase; // Enable RDFSBASE, RDGSBASE, WRFSBASE,
diff --git a/src/arch/x86/tlb.cc b/src/arch/x86/tlb.cc
index 270af19863..90e36fca89 100644
--- a/src/arch/x86/tlb.cc
+++ b/src/arch/x86/tlb.cc
@@ -486,19 +486,26 @@ TLB::translate(const RequestPtr &req,
             bool inUser = m5Reg.cpl == 3 && !(flags & CPL0FlagBit);
             CR0 cr0 = tc->readMiscRegNoEffect(misc_reg::Cr0);
             bool badWrite = (!entry->writable && (inUser || cr0.wp));
+            bool doUserFault = inUser && cr4.ufault && tc->readMiscRegNoEffect(X86ISA::misc_reg::Uff);
             if ((inUser && !entry->user) ||
                 (mode == BaseMMU::Write && badWrite)) {
                 // The page must have been present to get into the TLB in
                 // the first place. We'll assume the reserved bits are
                 // fine even though we're not checking them.
-                return std::make_shared<PageFault>(vaddr, true, mode, inUser,
-                                                   false);
+                if (doUserFault)
+                    return std::make_shared<UserFault>(vaddr, true, mode);
+                else
+                    return std::make_shared<PageFault>(vaddr, true, mode, inUser,
+                                                       false);
             }
             if (storeCheck && badWrite) {
                 // This would fault if this were a write, so return a page
                 // fault that reflects that happening.
-                return std::make_shared<PageFault>(
-                    vaddr, true, BaseMMU::Write, inUser, false);
+                if (doUserFault)
+                    return std::make_shared<UserFault>(vaddr, true, mode);
+                else
+                    return std::make_shared<PageFault>(
+                        vaddr, true, BaseMMU::Write, inUser, false);
             }
 
             Addr paddr = entry->paddr | (vaddr & mask(entry->logBytes));
-- 
2.52.0

