From 73de74fc7d4e10a412550fd977c9922bcf39a45e Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Mon, 26 Jan 2026 10:34:56 +0100
Subject: [PATCH 17/20] arch-x86: Add UFRET instruction

---
 src/arch/x86/isa/decoder/two_byte_opcodes.isa |  1 +
 .../interrupts_and_exceptions.py              | 47 +++++++++++++++++++
 2 files changed, 48 insertions(+)

diff --git a/src/arch/x86/isa/decoder/two_byte_opcodes.isa b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
index 9df5298bec..e7eb87709b 100644
--- a/src/arch/x86/isa/decoder/two_byte_opcodes.isa
+++ b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
@@ -151,6 +151,7 @@
                     0x3: decode MODRM_RM {
                         0x0: Cpl0Inst::SWAPGS();
                         0x1: Inst::RDTSCP();
+                        0x2: Inst::UFRET();
                         default: Inst::UD2();
                     }
                     default: Cpl0Inst::INVLPG(M);
diff --git a/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py b/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
index dc5615ba61..a1343e9151 100644
--- a/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
+++ b/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
@@ -484,6 +484,53 @@ skipOn:
     or t9, t9, t8, dataSize=4
     st t9, seg, [1, t0, t6], 0x300, dataSize=4, physical=True, uncacheable=True, atCPL0=True
 };
+
+def macroop UFRET {
+    # Pop tempRip;
+    # Pop tempRFLAGS;
+    # Pop tempRsp;
+
+    ld t1, ss, [1, t0, rsp], dataSize=8, addressSize=8
+    ld t2, ss, [1, t0, rsp], 8, dataSize=8, addressSize=8
+    ld t3, ss, [1, t0, rsp], 16, dataSize=8, addressSize=8
+    addi rsp, rsp, 24, dataSize=8
+
+    # IF tempRIP is not canonical in current paging mode
+    #     THEN #GP(0);
+    # FI;
+
+    srai t4, t1, 47, flags=(EZF,), dataSize=8
+
+    # If t4 is zero, then bits 47 to 63 are unset and this is a low canonical
+    # address.
+    br label("canonical"), flags=(CEZF,)
+
+    # Otherwise, we want to check if bits 47 to 63 are all set. Since the
+    # shift is arithmetic, this is equivalent to t4 being -1.
+    addi t0, t4, 1, flags=(EZF,), dataSize=8
+    fault "std::make_shared<GeneralProtection>(0)", flags=(nCEZF,)
+canonical:
+
+    # RIP := tempRip;
+    wrip t1, t0, dataSize=8
+
+    # // update in RFLAGS only CF, PF, AF, ZF, SF, TF, DF, OF, NT, RF, AC, and ID
+    # RFLAGS := (RFLAGS & ~254DD5H) | (tempRFLAGS & 254DD5H);
+    rflags t5, dataSize=8
+    limm t6, "~(uint64_t)0x254DD5", dataSize=8
+    limm t7, 0x254DD5, dataSize=8
+    and t8, t5, t6, dataSize=8
+    and t9, t2, t7, dataSize=8
+    or t10, t8, t9, dataSize=8
+    wrflags t10, t0, dataSize=8
+
+    # RSP := tempRsp;
+    mov rsp, t0, t3, dataSize=8
+
+    # UFF := 1;
+    limm t11, 1, dataSize=8
+    wrval ctrlRegIdx("misc_reg::Uff"), t11, dataSize=8
+};
 """
 # let {{
 #    class INT(Inst):
-- 
2.52.0

