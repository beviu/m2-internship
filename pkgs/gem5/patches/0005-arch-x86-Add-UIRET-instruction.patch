From 55ce0feb52d05c9897fd4944a2e9a5e1c16033c1 Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 9 Jan 2026 15:45:47 +0100
Subject: [PATCH 05/17] arch-x86: Add UIRET instruction

Most of the code is taken from Berk's great work.
---
 src/arch/x86/isa/decoder/two_byte_opcodes.isa |  1 +
 .../interrupts_and_exceptions.py              | 47 +++++++++++++++++++
 2 files changed, 48 insertions(+)

diff --git a/src/arch/x86/isa/decoder/two_byte_opcodes.isa b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
index 64ac45be95..20fd0ccab3 100644
--- a/src/arch/x86/isa/decoder/two_byte_opcodes.isa
+++ b/src/arch/x86/isa/decoder/two_byte_opcodes.isa
@@ -137,6 +137,7 @@
                     0x3: decode MODRM_RM {
                         0x0: BasicOperate::SERIALIZE({{/*Nothing*/}},
                                                          IsSerializeAfter);
+                        0x4: Inst::UIRET();
                         0x5: Inst::TESTUI();
                         0x6: Inst::CLUI();
                         0x7: Inst::STUI();
diff --git a/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py b/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
index 278d432e51..b665855323 100644
--- a/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
+++ b/src/arch/x86/isa/insts/general_purpose/control_transfer/interrupts_and_exceptions.py
@@ -341,6 +341,53 @@ def macroop INT_REAL_I {
 def macroop INT_VIRT_I {
     panic "Virtual mode int3 isn't implemented!"
 };
+
+def macroop UIRET {
+    # Pop tempRip;
+    ld t1, ss, [1, t0, rsp], dataSize=8, addressSize=8
+    addi rsp, rsp, 8, dataSize=8
+
+    # Pop tempRFLAGS;
+    ld t2, ss, [1, t0, rsp], dataSize=8, addressSize=8
+    addi rsp, rsp, 8, dataSize=8
+
+    # Pop tempRsp;
+    ld t3, ss, [1, t0, rsp], dataSize=8, addressSize=8
+    addi rsp, rsp, 8, dataSize=8
+
+    # IF tempRIP is not canonical in current paging mode
+    #     THEN #GP(0);
+    # FI;
+
+    srai t4, t1, 47, flags=(EZF,), dataSize=8
+    # If t4 is zero, then bits 47 to 63 are unset and this is a low canonical
+    # address.
+    br label("canonical"), flags=(CEZF,)
+    # Otherwise, we want to check if bits 47 to 63 are all set. Since the
+    # shift is arithmetic, this is equivalent to t4 being -1.
+    addi t0, t4, 1, flags=(EZF,), dataSize=8
+    fault "std::make_shared<GeneralProtection>(0)", flags=(nCEZF,)
+canonical:
+
+    # RIP := tempRip;
+    wrip t1, t0, dataSize=8
+
+    # RFLAGS := (RFLAGS & ~254DD5H) | (tempRFLAGS & 254DD5H);
+    limm t1, (0x254DD5), dataSize=8
+    and t1, t1, t2, dataSize=8
+    rflags t2, dataSize=8
+    limm t3, ~(0x254DD5), dataSize=8
+    and t2, t2, t3, dataSize=8
+    or t1, t1, t2, dataSize=8
+    wrflags t1, t0, dataSize=8
+
+    # RSP := tempRsp;
+    mov rsp, rsp, t3, dataSize=8
+
+    # UIF := 1;
+    limm t1, 1, dataSize=8
+    wrval ctrlRegIdx("misc_reg::Uif"), t1, dataSize=8
+};
 """
 # let {{
 #    class INT(Inst):
-- 
2.52.0

