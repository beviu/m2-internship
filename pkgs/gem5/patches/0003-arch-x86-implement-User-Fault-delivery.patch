From 53a4a484eec7b48fd0e88855bbd9b224bad1eae2 Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Mon, 5 Jan 2026 14:37:33 +0100
Subject: [PATCH 3/5] arch-x86: implement User Fault delivery

Most of the code is taken from Berk's great work!
---
 src/arch/x86/faults.cc            | 28 ++++++++++++++++++++
 src/arch/x86/faults.hh            | 32 ++++++++++++++++++++++
 src/arch/x86/isa/insts/romutil.py | 44 +++++++++++++++++++++++++++++++
 src/arch/x86/regs/misc.hh         |  5 +++-
 src/arch/x86/regs/msr.cc          |  3 +++
 src/arch/x86/tlb.cc               | 15 ++++++++---
 6 files changed, 122 insertions(+), 5 deletions(-)

diff --git a/src/arch/x86/faults.cc b/src/arch/x86/faults.cc
index fce92b1fb4..f0a428ce7c 100644
--- a/src/arch/x86/faults.cc
+++ b/src/arch/x86/faults.cc
@@ -179,6 +179,34 @@ PageFault::describe() const
     return ss.str();
 }
 
+void
+UserFault::invoke(ThreadContext *tc, const StaticInstPtr &inst)
+{
+    if (!FullSystem)
+        panic("User Faults are only supported in full-system mode.");
+
+    HandyM5Reg m5reg = tc->readMiscRegNoEffect(misc_reg::M5Reg);
+    if (m5reg.mode != LongMode)
+        panic("User Faults are only supported in long mode.");
+
+    // Invalidate any matching TLB entries before handling the page fault.
+    tc->getMMUPtr()->demapPage(addr, 0);
+
+    PCState pc = tc->pcState().as<PCState>();
+
+    DPRINTF(Faults, "RIP %#x: User Fault at %s\n", pc.pc(), addr);
+
+    Addr cs_base = tc->readMiscRegNoEffect(misc_reg::CsEffBase);
+    tc->setReg(intRegMicro(7), pc.pc() - cs_base);
+
+    MicroPC entry = X86ISAInst::rom_labels::extern_label_userFault;
+    pc.upc(romMicroPC(entry));
+    pc.nupc(romMicroPC(entry) + 1);
+
+    tc->pcState(pc);
+    tc->setMiscReg(misc_reg::Cr2, addr);
+}
+
 void
 InitInterrupt::invoke(ThreadContext *tc, const StaticInstPtr &inst)
 {
diff --git a/src/arch/x86/faults.hh b/src/arch/x86/faults.hh
index a1ff1b02c2..e7fd127c18 100644
--- a/src/arch/x86/faults.hh
+++ b/src/arch/x86/faults.hh
@@ -298,6 +298,38 @@ class PageFault : public X86Fault
     virtual std::string describe() const;
 };
 
+class UserFault : public FaultBase
+{
+  protected:
+    BitUnion8(UserFaultErrorCode)
+        Bitfield<0> present;
+        Bitfield<1> write;
+        Bitfield<2> fetch;
+    EndBitUnion(UserFaultErrorCode)
+
+    Addr addr;
+    UserFaultErrorCode code;
+
+  public:
+    UserFault(Addr _addr, bool present, BaseMMU::Mode mode) :
+        addr(_addr), code(0)
+    {
+        code.present = present;
+        code.write = (mode == BaseMMU::Write);
+        code.fetch = (mode == BaseMMU::Execute);
+    }
+
+    FaultName
+    name() const override
+    {
+        return "User Fault";
+    }
+
+    void
+    invoke(ThreadContext *tc, const StaticInstPtr &inst=
+                nullStaticInstPtr) override;
+};
+
 class X87FpExceptionPending : public X86Fault
 {
   public:
diff --git a/src/arch/x86/isa/insts/romutil.py b/src/arch/x86/isa/insts/romutil.py
index 7082b4d4a5..23915523d8 100644
--- a/src/arch/x86/isa/insts/romutil.py
+++ b/src/arch/x86/isa/insts/romutil.py
@@ -269,5 +269,49 @@ def rom
 
     eret
 };
+
+def rom
+{
+    # This processes a User Fault. On entry, the CPU is in long mode, t7 is the
+    # current ip and t15 contains the fault address and access bits. We need t7
+    # because rdip returns the next ip.
+    extern userFault:
+
+    rflags t10, dataSize=8
+
+    # holdRSP := RSP;
+    mov t6, t6, rsp, dataSize=8
+
+    # RSP := RSP & ~FH; // force the stack to be 16-byte aligned
+    limm t2, ~0xF, dataSize=8
+    and rsp, rsp, t2, dataSize=8
+
+    # Push holdRSP;
+    subi rsp, rsp, 8, dataSize=8
+    st t6, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push RFLAGS
+    subi rsp, rsp, 8, dataSize=8
+    st t10, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push RIP
+    subi rsp, rsp, 8, dataSize=8
+    st t7, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push the fault address and access bits.
+    subi rsp, rsp, 8, dataSize=8
+    st t15, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # RFLAGS.TF,RF := 0
+    limm t6, (1 << 8) | (1 << 16), dataSize=8
+    or t10, t10, t6, dataSize=8
+    wrflags t10, t6, dataSize=8
+
+    # RIP := UFHANDLER
+    rdval t1, ctrlRegIdx("misc_reg::UserFaultHandler")
+    wripi t1, 0, dataSize=8
+
+    eret
+};
 """
 )
diff --git a/src/arch/x86/regs/misc.hh b/src/arch/x86/regs/misc.hh
index 535d251948..1edf2bab0c 100644
--- a/src/arch/x86/regs/misc.hh
+++ b/src/arch/x86/regs/misc.hh
@@ -252,8 +252,11 @@ enum : RegIndex
     Mc7Misc,
     McMiscEnd,
 
+    UserFaultEnabled = McMiscEnd,
+    UserFaultHandler,
+
     // Extended feature enable register
-    Efer = McMiscEnd,
+    Efer,
 
     Star,
     Lstar,
diff --git a/src/arch/x86/regs/msr.cc b/src/arch/x86/regs/msr.cc
index 7fdb8841fd..45fe197d95 100644
--- a/src/arch/x86/regs/msr.cc
+++ b/src/arch/x86/regs/msr.cc
@@ -27,6 +27,7 @@
  */
 
 #include "arch/x86/regs/msr.hh"
+#include "arch/x86/regs/misc.hh"
 
 namespace gem5
 {
@@ -112,6 +113,8 @@ const MsrMap::value_type msrMapData[] = {
     MsrVal(0x417, misc_reg::Mc5Misc),
     MsrVal(0x41B, misc_reg::Mc6Misc),
     MsrVal(0x41F, misc_reg::Mc7Misc),
+    MsrVal(0x99D, misc_reg::UserFaultEnabled),
+    MsrVal(0x99E, misc_reg::UserFaultHandler),
     MsrVal(0xC0000080, misc_reg::Efer),
     MsrVal(0xC0000081, misc_reg::Star),
     MsrVal(0xC0000082, misc_reg::Lstar),
diff --git a/src/arch/x86/tlb.cc b/src/arch/x86/tlb.cc
index 270af19863..11293e10d6 100644
--- a/src/arch/x86/tlb.cc
+++ b/src/arch/x86/tlb.cc
@@ -486,19 +486,26 @@ TLB::translate(const RequestPtr &req,
             bool inUser = m5Reg.cpl == 3 && !(flags & CPL0FlagBit);
             CR0 cr0 = tc->readMiscRegNoEffect(misc_reg::Cr0);
             bool badWrite = (!entry->writable && (inUser || cr0.wp));
+            bool userFault = inUser && tc->readMiscRegNoEffect(X86ISA::misc_reg::UserFaultEnabled);
             if ((inUser && !entry->user) ||
                 (mode == BaseMMU::Write && badWrite)) {
                 // The page must have been present to get into the TLB in
                 // the first place. We'll assume the reserved bits are
                 // fine even though we're not checking them.
-                return std::make_shared<PageFault>(vaddr, true, mode, inUser,
-                                                   false);
+                if (userFault)
+                    return std::make_shared<UserFault>(vaddr, true, mode);
+                else
+                    return std::make_shared<PageFault>(vaddr, true, mode, inUser,
+                                                       false);
             }
             if (storeCheck && badWrite) {
                 // This would fault if this were a write, so return a page
                 // fault that reflects that happening.
-                return std::make_shared<PageFault>(
-                    vaddr, true, BaseMMU::Write, inUser, false);
+                if (userFault)
+                    return std::make_shared<UserFault>(vaddr, inUser, mode);
+                else
+                    return std::make_shared<PageFault>(
+                        vaddr, true, BaseMMU::Write, inUser, false);
             }
 
             Addr paddr = entry->paddr | (vaddr & mask(entry->logBytes));
-- 
2.52.0

