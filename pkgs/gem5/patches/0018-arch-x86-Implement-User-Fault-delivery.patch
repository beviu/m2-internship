From 7606e317a66f81714c8e19aaae30ec21ee526a7f Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Mon, 5 Jan 2026 14:37:33 +0100
Subject: [PATCH 18/19] arch-x86: Implement User Fault delivery

Code was written by Berk.
---
 src/arch/x86/faults.cc            | 31 ++++++++++++++++++++++
 src/arch/x86/faults.hh            | 32 ++++++++++++++++++++++
 src/arch/x86/isa/insts/romutil.py | 44 +++++++++++++++++++++++++++++++
 src/arch/x86/regs/misc.hh         |  1 +
 src/arch/x86/tlb.cc               | 15 ++++++++---
 5 files changed, 119 insertions(+), 4 deletions(-)

diff --git a/src/arch/x86/faults.cc b/src/arch/x86/faults.cc
index fce92b1fb4..f06699ad62 100644
--- a/src/arch/x86/faults.cc
+++ b/src/arch/x86/faults.cc
@@ -179,6 +179,37 @@ PageFault::describe() const
     return ss.str();
 }
 
+void
+UserFault::invoke(ThreadContext *tc, const StaticInstPtr &inst)
+{
+    if (!FullSystem)
+        panic("User Faults are only supported in full-system mode.");
+
+    HandyM5Reg m5reg = tc->readMiscRegNoEffect(misc_reg::M5Reg);
+    if (m5reg.mode != LongMode)
+        panic("User Faults are only supported in long mode.");
+
+    // Invalidate any matching TLB entries before handling the page fault.
+    tc->getMMUPtr()->demapPage(addr, 0);
+
+    PCState pc = tc->pcState().as<PCState>();
+
+    DPRINTF(Faults, "RIP %#x: User Fault at %s\n", pc.pc(), addr);
+
+    Addr cs_base = tc->readMiscRegNoEffect(misc_reg::CsEffBase);
+    tc->setReg(intRegMicro(7), pc.pc() - cs_base);
+
+    RegVal params = ((uint64_t)code << 60) | ((addr >> 3) << 3);
+    tc->setReg(intRegMicro(15), params);
+
+    MicroPC entry = X86ISAInst::rom_labels::extern_label_userFault;
+    pc.upc(romMicroPC(entry));
+    pc.nupc(romMicroPC(entry) + 1);
+
+    tc->pcState(pc);
+    tc->setMiscReg(misc_reg::Cr2, addr);
+}
+
 void
 InitInterrupt::invoke(ThreadContext *tc, const StaticInstPtr &inst)
 {
diff --git a/src/arch/x86/faults.hh b/src/arch/x86/faults.hh
index a1ff1b02c2..e7fd127c18 100644
--- a/src/arch/x86/faults.hh
+++ b/src/arch/x86/faults.hh
@@ -298,6 +298,38 @@ class PageFault : public X86Fault
     virtual std::string describe() const;
 };
 
+class UserFault : public FaultBase
+{
+  protected:
+    BitUnion8(UserFaultErrorCode)
+        Bitfield<0> present;
+        Bitfield<1> write;
+        Bitfield<2> fetch;
+    EndBitUnion(UserFaultErrorCode)
+
+    Addr addr;
+    UserFaultErrorCode code;
+
+  public:
+    UserFault(Addr _addr, bool present, BaseMMU::Mode mode) :
+        addr(_addr), code(0)
+    {
+        code.present = present;
+        code.write = (mode == BaseMMU::Write);
+        code.fetch = (mode == BaseMMU::Execute);
+    }
+
+    FaultName
+    name() const override
+    {
+        return "User Fault";
+    }
+
+    void
+    invoke(ThreadContext *tc, const StaticInstPtr &inst=
+                nullStaticInstPtr) override;
+};
+
 class X87FpExceptionPending : public X86Fault
 {
   public:
diff --git a/src/arch/x86/isa/insts/romutil.py b/src/arch/x86/isa/insts/romutil.py
index 7082b4d4a5..d4d8074da0 100644
--- a/src/arch/x86/isa/insts/romutil.py
+++ b/src/arch/x86/isa/insts/romutil.py
@@ -269,5 +269,49 @@ def rom
 
     eret
 };
+
+def rom
+{
+    # This processes a User Fault. On entry, the CPU is in long mode, t7 is the
+    # current ip and t15 contains the fault address and access bits. We need t7
+    # because rdip returns the next ip.
+    extern userFault:
+
+    rflags t10, dataSize=8
+
+    # holdRSP := RSP;
+    mov t6, t6, rsp, dataSize=8
+
+    # RSP := RSP & ~FH; // force the stack to be 16-byte aligned
+    limm t2, ~0xF, dataSize=8
+    and rsp, rsp, t2, dataSize=8
+
+    # Push holdRSP;
+    subi rsp, rsp, 8, dataSize=8
+    st t6, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push RFLAGS
+    subi rsp, rsp, 8, dataSize=8
+    st t10, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push RIP
+    subi rsp, rsp, 8, dataSize=8
+    st t7, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # Push the fault address and access bits.
+    subi rsp, rsp, 8, dataSize=8
+    st t15, ss, [1, t0, rsp], dataSize=8, addressSize=8
+
+    # RFLAGS.TF,RF := 0
+    limm t6, (1 << 8) | (1 << 16), dataSize=8
+    or t10, t10, t6, dataSize=8
+    wrflags t10, t6, dataSize=8
+
+    # RIP := UFHANDLER
+    rdval t1, ctrlRegIdx("misc_reg::Ufhandler"), dataSize=8
+    wripi t1, 0, dataSize=8
+
+    eret
+};
 """
 )
diff --git a/src/arch/x86/regs/misc.hh b/src/arch/x86/regs/misc.hh
index 0d49bfe9da..5456f4bbab 100644
--- a/src/arch/x86/regs/misc.hh
+++ b/src/arch/x86/regs/misc.hh
@@ -646,6 +646,7 @@ BitUnion64(CR3)
 EndBitUnion(CR3)
 
 BitUnion64(CR4)
+    Bitfield<26> ufault; // Enable User Faults
     Bitfield<18> osxsave; // Enable XSAVE and Proc Extended States
     Bitfield<17> pcide; // PCID Enable
     Bitfield<16> fsgsbase; // Enable RDFSBASE, RDGSBASE, WRFSBASE,
diff --git a/src/arch/x86/tlb.cc b/src/arch/x86/tlb.cc
index 270af19863..4679f7d02e 100644
--- a/src/arch/x86/tlb.cc
+++ b/src/arch/x86/tlb.cc
@@ -486,19 +486,26 @@ TLB::translate(const RequestPtr &req,
             bool inUser = m5Reg.cpl == 3 && !(flags & CPL0FlagBit);
             CR0 cr0 = tc->readMiscRegNoEffect(misc_reg::Cr0);
             bool badWrite = (!entry->writable && (inUser || cr0.wp));
+            bool userFault = inUser && cr4.ufault && tc->readMiscRegNoEffect(X86ISA::misc_reg::Uif);
             if ((inUser && !entry->user) ||
                 (mode == BaseMMU::Write && badWrite)) {
                 // The page must have been present to get into the TLB in
                 // the first place. We'll assume the reserved bits are
                 // fine even though we're not checking them.
-                return std::make_shared<PageFault>(vaddr, true, mode, inUser,
-                                                   false);
+                if (userFault)
+                    return std::make_shared<UserFault>(vaddr, true, mode);
+                else
+                    return std::make_shared<PageFault>(vaddr, true, mode, inUser,
+                                                       false);
             }
             if (storeCheck && badWrite) {
                 // This would fault if this were a write, so return a page
                 // fault that reflects that happening.
-                return std::make_shared<PageFault>(
-                    vaddr, true, BaseMMU::Write, inUser, false);
+                if (userFault)
+                    return std::make_shared<UserFault>(vaddr, inUser, mode);
+                else
+                    return std::make_shared<PageFault>(
+                        vaddr, true, BaseMMU::Write, inUser, false);
             }
 
             Addr paddr = entry->paddr | (vaddr & mask(entry->logBytes));
-- 
2.52.0

