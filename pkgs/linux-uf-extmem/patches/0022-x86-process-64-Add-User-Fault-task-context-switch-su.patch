From 92c3ed8a198c7e44ba49452a3ebb3c3ab9ad2cc9 Mon Sep 17 00:00:00 2001
From: beviu <contact@beviu.com>
Date: Fri, 25 Jul 2025 13:33:10 +0200
Subject: [PATCH 22/29] x86/process/64: Add User Fault task context switch
 support

---
 arch/x86/include/asm/entry-common.h |  4 ++++
 arch/x86/include/asm/processor.h    |  3 +++
 arch/x86/include/asm/ufault.h       |  9 +++++++++
 arch/x86/kernel/Makefile            |  1 +
 arch/x86/kernel/process_64.c        |  4 ++++
 arch/x86/kernel/ufault.c            | 14 ++++++++++++++
 6 files changed, 35 insertions(+)
 create mode 100644 arch/x86/kernel/ufault.c

diff --git a/arch/x86/include/asm/entry-common.h b/arch/x86/include/asm/entry-common.h
index cb42f592a8f0..1205ff7e3452 100644
--- a/arch/x86/include/asm/entry-common.h
+++ b/arch/x86/include/asm/entry-common.h
@@ -9,6 +9,7 @@
 #include <asm/io_bitmap.h>
 #include <asm/fpu/api.h>
 #include <asm/uintr.h>
+#include <asm/ufault.h>
 
 /* Check that the stack and regs on entry from user mode are sane. */
 static __always_inline void arch_enter_from_user_mode(struct pt_regs *regs)
@@ -61,6 +62,9 @@ static inline void arch_exit_to_user_mode_prepare(struct pt_regs *regs,
 	if (cpu_feature_enabled(X86_FEATURE_UINTR))
 		switch_uintr_return();
 
+	if (cpu_feature_enabled(X86_FEATURE_UFAULT))
+		switch_ufault_return();
+
 #ifdef CONFIG_COMPAT
 	/*
 	 * Compat syscalls set TS_COMPAT.  Make sure we clear it before
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index 0859583f7192..fdade9df13a3 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -533,6 +533,9 @@ struct thread_struct {
 	struct uintr_upid_ctx	*upid_ctx;
 #endif
 
+	unsigned long		ufault_handler;
+	unsigned int		ufault_enabled:1;
+
 	/*
 	 * Protection Keys Register for Userspace.  Loaded immediately on
 	 * context switch. Store it in thread_struct to avoid a lookup in
diff --git a/arch/x86/include/asm/ufault.h b/arch/x86/include/asm/ufault.h
index 96fb6f796d82..2ed9941bf48c 100644
--- a/arch/x86/include/asm/ufault.h
+++ b/arch/x86/include/asm/ufault.h
@@ -2,6 +2,7 @@
 #ifndef _ASM_X86_UFAULT_H
 #define _ASM_X86_UFAULT_H
 
+#include <linux/sched.h>
 #include <linux/types.h>
 
 #ifdef CONFIG_X86_USER_FAULTS
@@ -22,6 +23,14 @@ static __always_inline void stuf(void) {
 	asm volatile(".long 0xea010ff3" ::: "memory");
 }
 
+void switch_ufault_prepare(struct task_struct *prev);
+void switch_ufault_return(void);
+
+#else /* !CONFIG_X86_USER_FAULTS */
+
+static inline void switch_ufault_prepare(struct task_struct *prev) {}
+static inline void switch_ufault_return(void) {}
+
 #endif /* CONFIG_X86_USER_FAULTS */
 
 #endif /* _ASM_X86_UFAULT_H */
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 796db2497075..3685f17db777 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -132,6 +132,7 @@ obj-$(CONFIG_PERF_EVENTS)		+= perf_regs.o
 obj-$(CONFIG_TRACING)			+= tracepoint.o
 obj-$(CONFIG_SCHED_MC_PRIO)		+= itmt.o
 obj-$(CONFIG_X86_USER_INTERRUPTS)	+= uintr.o
+obj-$(CONFIG_X86_USER_FAULTS)		+= ufault.o
 obj-$(CONFIG_X86_UMIP)			+= umip.o
 
 obj-$(CONFIG_UNWINDER_ORC)		+= unwind_orc.o
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 28d4c3ec3f82..dfa314a8345d 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -53,6 +53,7 @@
 #include <asm/xen/hypervisor.h>
 #include <asm/vdso.h>
 #include <asm/resctrl.h>
+#include <asm/ufault.h>
 #include <asm/uintr.h>
 #include <asm/unistd.h>
 #include <asm/fsgsbase.h>
@@ -568,6 +569,9 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 	if (cpu_feature_enabled(X86_FEATURE_UINTR))
 		switch_uintr_prepare(prev_p);
 
+	if (cpu_feature_enabled(X86_FEATURE_UFAULT))
+		switch_ufault_prepare(prev_p);
+
 	if (!test_thread_flag(TIF_NEED_FPU_LOAD))
 		switch_fpu_prepare(prev_fpu, cpu);
 
diff --git a/arch/x86/kernel/ufault.c b/arch/x86/kernel/ufault.c
new file mode 100644
index 000000000000..3453839facb8
--- /dev/null
+++ b/arch/x86/kernel/ufault.c
@@ -0,0 +1,14 @@
+#include <asm/ufault.h>
+
+void switch_ufault_prepare(struct task_struct *prev)
+{
+	current->thread.ufault_enabled = testuf();
+}
+
+void switch_ufault_return(void)
+{
+	wrmsrl(MSR_IA32_UFAULT_HANDLER, current->thread.ufault_handler);
+
+	if (current->thread.ufault_enabled)
+		stuf();
+}
-- 
2.52.0

